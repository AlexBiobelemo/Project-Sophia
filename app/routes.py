"""Defines the routes and view functions for the Sophia application."""

import numpy as np
import sqlalchemy as sa
from sqlalchemy import or_
from flask import (Blueprint, render_template, flash, redirect, url_for,
                   request, current_app, jsonify)
from flask_login import current_user, login_user, logout_user, login_required

from app import db, ai_services
from app.ai_services import cosine_similarity
from app.forms import (RegistrationForm, LoginForm, SnippetForm,
                       AIGenerationForm, CollectionForm,
                       LeetcodeProblemForm, GenerateSolutionForm, ApproveSolutionForm)
from app.models import User, Snippet, Collection, LeetcodeProblem, LeetcodeSolution
from io import StringIO

# Create the main Blueprint
bp = Blueprint('main', __name__)


@bp.route('/')
@bp.route('/index')
def index():
    """Renders the homepage, displaying snippets for logged-in users."""
    page = request.args.get('page', 1, type=int)
    pagination = None
    if current_user.is_authenticated:
        # Query for the user's snippets and paginate the results
        pagination = current_user.snippets.order_by(Snippet.timestamp.desc()).paginate(
            page=page, per_page=current_app.config['POSTS_PER_PAGE'], error_out=False)

    return render_template('index.html', title='Home', snippets=pagination)


@bp.route('/login', methods=['GET', 'POST'])
def login():
    """Handles user login."""
    if current_user.is_authenticated:
        return redirect(url_for('main.index'))
    form = LoginForm()
    if form.validate_on_submit():
        user = db.session.scalar(
            sa.select(User).where(User.username == form.username.data))
        if user is None or not user.check_password(form.password.data):
            flash('Invalid username or password', 'danger')
            return redirect(url_for('main.login'))
        login_user(user, remember=form.remember_me.data)
        return redirect(url_for('main.index'))
    return render_template('login.html', title='Sign In', form=form)


@bp.route('/logout')
def logout():
    """Handles user logout."""
    logout_user()
    return redirect(url_for('main.index'))


@bp.route('/register', methods=['GET', 'POST'])
def register():
    """Handles new user registration."""
    if current_user.is_authenticated:
        return redirect(url_for('main.index'))
    form = RegistrationForm()
    if form.validate_on_submit():
        user = User(username=form.username.data, email=form.email.data)
        user.set_password(form.password.data)
        db.session.add(user)
        db.session.commit()
        flash('Congratulations, you are now a registered user!', 'success')
        return redirect(url_for('main.login'))
    return render_template('register.html', title='Register', form=form)


@bp.route('/snippet/<int:snippet_id>')
@login_required
def view_snippet(snippet_id):
    """Displays a single code snippet in detail."""
    snippet = db.session.get(Snippet, snippet_id)
    # Security check: ensure snippet exists and belongs to the current user
    if snippet is None or snippet.author != current_user:
        flash('Snippet not found or you do not have permission to view it.', 'danger')
        return redirect(url_for('main.index'))
    return render_template('view_snippet.html', title=snippet.title, snippet=snippet)


@bp.route('/create_snippet', methods=['GET', 'POST'])
@login_required
def create_snippet():
    """Handles creation of new snippets."""
    form = SnippetForm()
    # Populate the collection dropdown with the user's collections
    form.collection.choices = [(c.id, c.name) for c in current_user.collections.all()]
    form.collection.choices.insert(0, (0, '--- No Collection ---'))

    if request.method == 'GET':
        # If code was generated by AI, pre-populate the form
        generated_code = request.args.get('generated_code')
        generated_explanation = request.args.get('generated_explanation')
        if generated_code:
            form.code.data = generated_code
        if generated_explanation:
            form.description.data = generated_explanation

    if form.validate_on_submit():
        collection_id = form.collection.data if form.collection.data != 0 else None
        snippet = Snippet(
            title=form.title.data,
            description=form.description.data,
            code=form.code.data,
            author=current_user,
            tags=form.tags.data,
            language=form.language.data,
            collection_id=collection_id
        )
        snippet.generate_and_set_embedding()
        db.session.add(snippet)
        db.session.commit()
        current_app.award_points(current_user, 10, "Snippet Created") # Award points for creating a snippet
        flash('Your snippet has been saved!', 'success')
        return redirect(url_for('main.index'))

    return render_template('create_snippet.html', title='Create Snippet', form=form)


@bp.route('/snippet/<int:snippet_id>/edit', methods=['GET', 'POST'])
@login_required
def edit_snippet(snippet_id):
    """Handles editing an existing snippet."""
    snippet = db.session.get(Snippet, snippet_id)
    if snippet is None or snippet.author != current_user:
        flash('Snippet not found or you do not have permission to edit it.', 'danger')
        return redirect(url_for('main.index'))

    form = SnippetForm(obj=snippet)
    form.collection.choices = [(c.id, c.name) for c in current_user.collections.all()]
    form.collection.choices.insert(0, (0, '--- No Collection ---'))

    if form.validate_on_submit():
        collection_id = form.collection.data if form.collection.data != 0 else None
        snippet.title = form.title.data
        snippet.description = form.description.data
        snippet.code = form.code.data
        snippet.tags = form.tags.data
        snippet.language = form.language.data
        snippet.collection_id = collection_id
        snippet.generate_and_set_embedding()
        db.session.commit()
        flash('Your snippet has been updated!', 'success')
        return redirect(url_for('main.view_snippet', snippet_id=snippet.id))

    elif request.method == 'GET':
        # Pre-select the correct collection in the dropdown
        form.collection.data = snippet.collection_id or 0

    return render_template('edit_snippet.html', title='Edit Snippet', form=form, snippet=snippet)


@bp.route('/snippet/<int:snippet_id>/delete', methods=['POST'])
@login_required
def delete_snippet(snippet_id):
    """Handles deleting a snippet."""
    snippet = db.session.get(Snippet, snippet_id)
    if snippet is None or snippet.author != current_user:
        flash('Snippet not found or you do not have permission to delete it.', 'danger')
        return redirect(url_for('main.index'))

    db.session.delete(snippet)
    db.session.commit()
    flash('Your snippet has been deleted.', 'success')
    return redirect(url_for('main.index'))


@bp.route('/generate', methods=['GET', 'POST'])
@login_required
def generate():
    """Renders the AI code generation page and handles form submission."""
    form = AIGenerationForm()
    if form.validate_on_submit():
        prompt = form.prompt.data
        flash('Generating your code... please wait.', 'info')
        generated_code = ai_services.generate_code_from_prompt(prompt)

        if "Error:" in generated_code:
            flash(generated_code, 'danger')
            return redirect(url_for('main.generate'))

        generated_explanation = ai_services.explain_code(generated_code)

        # Redirect to create page with code and explanation pre-filled
        return redirect(url_for('main.create_snippet', generated_code=generated_code, generated_explanation=generated_explanation))

    return render_template('generate.html', title='AI Code Generation', form=form)


@bp.route('/explain', methods=['POST'])
@login_required
def explain():
    """API endpoint to get an AI explanation for a code block."""
    data = request.get_json()
    if not data or 'code' not in data:
        return jsonify({'error': 'Missing code in request.'}), 400

    code = data['code']
    explanation = ai_services.explain_code(code)
    return jsonify({'explanation': explanation})


@bp.route('/suggest-tags', methods=['POST'])
@login_required
def suggest_tags():
    """API endpoint to get AI-suggested tags for code."""
    data = request.get_json()
    if not data or 'code' not in data:
        return jsonify({'error': 'Missing code in request.'}), 400

    code = data['code']
    suggested_tags = ai_services.suggest_tags_for_code(code)
    return jsonify({'tags': suggested_tags})


@bp.route('/search')
@login_required
def search():
    """Handles hybrid (keyword and semantic) search for snippets."""
    query = request.args.get('q', '')
    if not query:
        return redirect(url_for('main.index'))

    # --- Keyword Search ---
    keyword_results = db.session.scalars(
        sa.select(Snippet).where(
            Snippet.user_id == current_user.id,
            or_(
                Snippet.title.ilike(f'%{query}%'),
                Snippet.description.ilike(f'%{query}%'),
                Snippet.code.ilike(f'%{query}%'),
                Snippet.tags.ilike(f'%{query}%')
            )
        )
    ).all()

    # --- Semantic Search ---
    query_embedding = ai_services.generate_embedding(
        query, task_type="RETRIEVAL_QUERY")

    semantic_results = []
    if query_embedding is not None:
        query_vector = np.array(query_embedding)
        
        # Filter snippets to ensure embeddings are valid
        valid_snippets_with_embeddings = []
        for s in current_user.snippets.order_by(Snippet.timestamp.desc()).all():
            if s.embedding is not None and isinstance(s.embedding, list) and len(s.embedding) > 0:
                if all(isinstance(x, (int, float)) for x in s.embedding):
                    valid_snippets_with_embeddings.append(s)

        if valid_snippets_with_embeddings:
            snippet_vectors = {s.id: np.array(s.embedding, dtype=np.float32)
                               for s in valid_snippets_with_embeddings}

            similarities = {
                sid: ai_services.cosine_similarity(query_vector, s_vector)
                for sid, s_vector in snippet_vectors.items()
            }

            SIMILARITY_THRESHOLD = 0.65
            relevant_ids = {
                sid: score for sid, score in similarities.items()
                if score > SIMILARITY_THRESHOLD
            }

            snippet_map = {s.id: s for s in valid_snippets_with_embeddings}
            semantic_results = [snippet_map[sid] for sid in sorted(
                relevant_ids, key=relevant_ids.get, reverse=True)]

    # --- Combine and Re-rank Results ---
    combined_results = {} # {snippet_id: snippet_object}

    # Add keyword results with a base score
    for snippet in keyword_results:
        combined_results[snippet.id] = {'snippet': snippet, 'score': 0.1} # Base score for keyword match

    # Add semantic results, boosting scores if already present from keyword search
    for snippet in semantic_results:
        if snippet.id in combined_results:
            # If already found by keyword, boost its score with semantic similarity
            combined_results[snippet.id]['score'] += similarities[snippet.id]
        else:
            # Otherwise, add it with its semantic similarity score
            combined_results[snippet.id] = {'snippet': snippet, 'score': similarities[snippet.id]}

    # Sort by combined score
    sorted_snippets_with_scores = sorted(
        combined_results.values(), key=lambda x: x['score'], reverse=True
    )
    final_sorted_snippets = [item['snippet'] for item in sorted_snippets_with_scores]

    if not final_sorted_snippets:
        flash('No snippets found matching your search.', 'info')

    return render_template('search_results.html', title='Search Results', results=final_sorted_snippets, query=query)


@bp.route('/collections', methods=['GET', 'POST'])
@login_required
def collections():
    """Page for viewing and managing collections."""
    form = CollectionForm()
    # Populate parent_collection choices, excluding the collection itself if editing
    form.parent_collection.choices = [(0, '--- No Parent ---')] + \
                                     [(c.id, c.name) for c in current_user.collections.filter_by(parent_id=None).order_by(Collection.name).all()]

    if form.validate_on_submit():
        parent_id = form.parent_collection.data if form.parent_collection.data != 0 else None
        collection = Collection(name=form.name.data, user_id=current_user.id, parent_id=parent_id)
        db.session.add(collection)
        db.session.commit()
        flash('New collection created!', 'success')
        return redirect(url_for('main.collections'))

    # Fetch top-level collections (those without a parent)
    user_collections = db.session.query(Collection).filter_by(
        user_id=current_user.id, parent_id=None).order_by(Collection.order.asc(), Collection.name.asc()).all()

    # Get total snippet count for the user
    total_snippets_count = current_user.snippets.count()

    # Get snippet count for each collection
    collections_with_counts = []
    for collection in user_collections:
        snippet_count = collection.snippets.count()
        collections_with_counts.append({'collection': collection, 'snippet_count': snippet_count})

    return render_template('collections.html', title='My Solutions', form=form,
                           collections=collections_with_counts, total_snippets_count=total_snippets_count)

@bp.route('/collection/<int:collection_id>')
@login_required
def view_collection(collection_id):
    """Page to view all snippets within a single collection."""
    page = request.args.get('page', 1, type=int)
    collection = db.session.get(Collection, collection_id)
    if collection is None or collection.owner != current_user:
        flash('Collection not found.', 'danger')
        return redirect(url_for('main.collections'))

    # Query for snippets in this collection and paginate the results
    pagination = collection.snippets.order_by(Snippet.timestamp.desc()).paginate(
        page=page, per_page=current_app.config['POSTS_PER_PAGE'], error_out=False)
    
    # Fetch sub-collections
    sub_collections = collection.children.order_by(Collection.name.asc()).all()

    return render_template(
        'view_collection.html',
        title=f"Collection: {collection.name}",
        collection=collection,
        snippets=pagination,
        snippet_count=collection.snippets.count(),
        sub_collections=sub_collections
    )

@bp.route('/collection/<int:collection_id>/rename', methods=['GET', 'POST'])
@login_required
def rename_collection(collection_id):
    """Handles renaming a collection."""
    collection = db.session.get(Collection, collection_id)
    if collection is None or collection.owner != current_user:
        flash('Collection not found.', 'danger')
        return redirect(url_for('main.collections'))

    form = CollectionForm(obj=collection)
    # Populate parent_collection choices, excluding the collection itself and its descendants
    form.parent_collection.choices = [(0, '--- No Parent ---')]
    
    # Get all collections that are not the current collection or its children
    eligible_parents = current_user.collections.filter(
        Collection.id != collection.id,
        ~Collection.parent_id.in_([c.id for c in collection.children]) # Exclude direct children
    ).order_by(Collection.name).all()

    form.parent_collection.choices.extend([(c.id, c.name) for c in eligible_parents])

    if form.validate_on_submit():
        collection.name = form.name.data
        parent_id = form.parent_collection.data if form.parent_collection.data != 0 else None
        collection.parent_id = parent_id
        db.session.commit()
        flash('Collection has been updated!', 'success')
        return redirect(url_for('main.collections'))

    elif request.method == 'GET':
        form.name.data = collection.name
        form.parent_collection.data = collection.parent_id or 0

    return render_template('rename_collection.html', title='Edit Collection', form=form, collection=collection)


@bp.route('/collection/<int:collection_id>/delete', methods=['POST'])
@login_required
def delete_collection(collection_id):
    """Handles deleting a collection."""
    collection = db.session.get(Collection, collection_id)
    if collection is None or collection.owner != current_user:
        flash('Collection not found.', 'danger')
        return redirect(url_for('main.collections'))

    # Un-assign snippets from the collection before deleting it
    for snippet in collection.snippets:
        snippet.collection_id = None

    db.session.delete(collection)
    db.session.commit()
    flash('Collection deleted successfully.', 'success')
    return redirect(url_for('main.collections'))


@bp.route('/add_problem', methods=['GET', 'POST'])
@login_required
def add_problem():
    form = LeetcodeProblemForm()
    if form.validate_on_submit():
        problem = LeetcodeProblem(
            title=form.title.data,
            description=form.description.data,
            difficulty=form.difficulty.data,
            tags=form.tags.data,
            leetcode_url=form.leetcode_url.data,
            author=current_user
        )
        db.session.add(problem)
        db.session.commit()
        flash('Leetcode problem added successfully!', 'success')
        return redirect(url_for('main.index'))
    return render_template('add_problem.html', title='Add Leetcode Problem', form=form)


@bp.route('/problem/<int:problem_id>')
@login_required
def view_problem(problem_id):
    problem = db.session.get(LeetcodeProblem, problem_id)
    if problem is None:
        flash('Problem not found.', 'danger')
        return redirect(url_for('main.index'))
    
    solutions = problem.solutions.filter_by(approved=True).order_by(LeetcodeSolution.timestamp.desc()).all()
    return render_template('view_problem.html', title=problem.title, problem=problem, solutions=solutions)


@bp.route('/generate_solution/<int:problem_id>', methods=['GET', 'POST'])
@login_required
def generate_solution(problem_id):
    problem = db.session.get(LeetcodeProblem, problem_id)
    if problem is None:
        flash('Problem not found.', 'danger')
        return redirect(url_for('main.index'))

    form = GenerateSolutionForm()
    form.problem.choices = [(problem.id, problem.title)] # Pre-select the current problem
    form.problem.data = problem.id # Set default value

    if form.validate_on_submit():
        language = form.language.data
        flash(f'Generating {language} solution for "{problem.title}"...', 'info')
        
        solution_code = ai_services.generate_leetcode_solution(
            problem.title, problem.description, language
        )
        
        if "Error:" in solution_code:
            flash(solution_code, 'danger')
            return redirect(url_for('main.view_problem', problem_id=problem.id))

        explanation = ai_services.explain_leetcode_solution(
            solution_code, problem.title, language
        )
        classification = ai_services.classify_leetcode_solution(
            solution_code, problem.description
        )

        solution = LeetcodeSolution(
            problem=problem,
            contributor=current_user,
            solution_code=solution_code,
            language=language,
            explanation=explanation,
            classification=classification,
            approved=False # Solutions need approval
        )
        solution.generate_and_set_embedding()
        db.session.add(solution)
        db.session.commit()
        flash('Solution generated and awaiting approval!', 'success')
        return redirect(url_for('main.view_solution', solution_id=solution.id))

    return render_template('generate_solution.html', title='Generate Solution', form=form, problem=problem)


@bp.route('/solution/<int:solution_id>')
@login_required
def view_solution(solution_id):
    solution = db.session.get(LeetcodeSolution, solution_id)
    if solution is None:
        flash('Solution not found.', 'danger')
        return redirect(url_for('main.index'))
    
    # Only allow viewing if approved or if current user is the contributor
    if not solution.approved and solution.contributor != current_user:
        flash('This solution is awaiting approval and cannot be viewed yet.', 'warning')
        return redirect(url_for('main.view_problem', problem_id=solution.problem.id))

    return render_template('view_solution.html', title=f"Solution for {solution.problem.title}", solution=solution)


@bp.route('/solution/<int:solution_id>/approve', methods=['GET', 'POST'])
@login_required
def approve_solution(solution_id):
    solution = db.session.get(LeetcodeSolution, solution_id)
    if solution is None:
        flash('Solution not found.', 'danger')
        return redirect(url_for('main.index'))
    
    # Only the problem author or an admin (if we implement roles) can approve
    if solution.problem.author != current_user:
        flash('You do not have permission to approve this solution.', 'danger')
        return redirect(url_for('main.view_solution', solution_id=solution.id))

    form = ApproveSolutionForm(obj=solution)
    if form.validate_on_submit():
        solution.approved = form.approve.data
        db.session.commit()
        if solution.approved:
            current_app.award_points(current_user, 20, "Solution Approved") # Award points for approving a solution
        flash('Solution approval status updated.', 'success')
        return redirect(url_for('main.view_problem', problem_id=solution.problem.id))
    
    return render_template('approve_solution.html', title='Approve Solution', form=form, solution=solution)


@bp.route('/export_snippets')
@login_required
def export_snippets():
    """Renders the page for exporting snippets."""
    return render_template('export_snippets.html', title='Export Snippets')

@bp.route('/api/export_snippets')
@login_required
def api_export_snippets():
    """Exports user's snippets as segmented JSON for rendering."""
    snippets_data = []
    for snippet in current_user.snippets.order_by(Snippet.timestamp.desc()).all():
        snippets_data.append({
            'id': snippet.id,
            'title': snippet.title,
            'description': snippet.description,
            'code': snippet.code,
            'language': snippet.language,
            'tags': snippet.tags,
            'collection': snippet.collection.name if snippet.collection else 'None',
            'created_at': snippet.timestamp.isoformat()
        })
    return jsonify(snippets_data)


@bp.route('/export/download')
@login_required
def download_selected_snippets():
    """Handles downloading selected snippets as a Markdown file."""
    snippet_ids_str = request.args.get('ids')
    
    if snippet_ids_str:
        try:
            snippet_ids = [int(s_id) for s_id in snippet_ids_str.split(',')]
        except ValueError:
            flash('Invalid snippet IDs provided.', 'danger')
            return redirect(url_for('main.export_snippets'))

        # Fetch snippets belonging to the current user and matching the provided IDs
        selected_snippets = db.session.scalars(
            sa.select(Snippet).where(
                Snippet.id.in_(snippet_ids),
                Snippet.user_id == current_user.id
            )
        ).all()
    else:
        # If no specific IDs are provided, export all snippets for the current user
        selected_snippets = current_user.snippets.order_by(Snippet.timestamp.desc()).all()

    if not selected_snippets:
        flash('No snippets found to export.', 'danger')
        return redirect(url_for('main.export_snippets'))

    if not selected_snippets:
        flash('No matching snippets found or you do not have permission to download them.', 'danger')
        return redirect(url_for('main.export_snippets'))

    markdown_content = []
    markdown_content.append("# Exported Snippets from Project Sophia\n\n")
    markdown_content.append("---")

    for snippet in selected_snippets:
        markdown_content.append(f"\n\n## {snippet.title}\n")
        markdown_content.append(f"**Language:** {snippet.language}\n")
        if snippet.tags:
            markdown_content.append(f"**Tags:** {snippet.tags}\n")
        if snippet.collection:
            markdown_content.append(f"**Collection:** {snippet.collection.name}\n")
        markdown_content.append(f"**Created At:** {snippet.timestamp.strftime('%Y-%m-%d %H:%M:%S')}\n")
        
        if snippet.description:
            markdown_content.append("\n### Description:\n")
            markdown_content.append(f"{snippet.description}\n")
        
        markdown_content.append("\n### Code:\n")
        markdown_content.append(f"```{snippet.language.lower() if snippet.language else ''}\n")
        markdown_content.append(f"{snippet.code}\n")
        markdown_content.append("```\n")
        markdown_content.append("\n---") # Separator between snippets

    full_markdown = "\n".join(markdown_content)

    return current_app.response_class(
        full_markdown,
        headers={
            'Content-Disposition': 'attachment;filename=sophia_snippets.md',
            'Content-Type': 'text/markdown'
        },
        mimetype='text/markdown'
    )


@bp.route('/search_solutions')
@login_required
def search_solutions():
    """Handles hybrid (keyword and semantic) search for Leetcode solutions."""
    query = request.args.get('q', '')
    if not query:
        return redirect(url_for('main.index'))

    # --- Keyword Search ---
    keyword_results = db.session.scalars(
        sa.select(LeetcodeSolution).where(
            LeetcodeSolution.approved == True,
            or_(
                LeetcodeSolution.solution_code.ilike(f'%{query}%'),
                LeetcodeSolution.explanation.ilike(f'%{query}%'),
                LeetcodeSolution.classification.ilike(f'%{query}%'),
                LeetcodeSolution.problem.has(LeetcodeProblem.title.ilike(f'%{query}%')),
                LeetcodeSolution.problem.has(LeetcodeProblem.description.ilike(f'%{query}%')),
                LeetcodeSolution.problem.has(LeetcodeProblem.tags.ilike(f'%{query}%'))
            )
        )
    ).all()

    # --- Semantic Search ---
    query_embedding = ai_services.generate_embedding(
        query, task_type="RETRIEVAL_QUERY")

    semantic_results = []
    if query_embedding is not None:
        query_vector = np.array(query_embedding)

        # Search only approved solutions with valid embeddings
        valid_solutions_with_embeddings = LeetcodeSolution.query.filter(
            LeetcodeSolution.approved == True,
            LeetcodeSolution.embedding.isnot(None)
        ).all()

        # Filter to ensure embeddings are valid (not None, not empty, and contain only numbers)
        filtered_solutions = []
        for s in valid_solutions_with_embeddings:
            if s.embedding is not None and isinstance(s.embedding, list) and len(s.embedding) > 0:
                if all(isinstance(x, (int, float)) for x in s.embedding):
                    filtered_solutions.append(s)

        if filtered_solutions:
            solution_vectors = {s.id: np.array(s.embedding, dtype=np.float32)
                               for s in filtered_solutions}

            similarities = {
                sid: ai_services.cosine_similarity(query_vector, s_vector)
                for sid, s_vector in solution_vectors.items()
            }

            SIMILARITY_THRESHOLD = 0.65
            relevant_ids = {
                sid: score for sid, score in similarities.items()
                if score > SIMILARITY_THRESHOLD
            }

            solution_map = {s.id: s for s in filtered_solutions}
            semantic_results = [solution_map[sid] for sid in sorted(
                relevant_ids, key=relevant_ids.get, reverse=True)]

    # --- Combine and Re-rank Results ---
    combined_results = {} # {solution_id: solution_object}

    # Add keyword results with a base score
    for solution in keyword_results:
        combined_results[solution.id] = {'solution': solution, 'score': 0.1} # Base score for keyword match

    # Add semantic results, boosting scores if already present from keyword search
    for solution in semantic_results:
        if solution.id in combined_results:
            # If already found by keyword, boost its score with semantic similarity
            combined_results[solution.id]['score'] += similarities[solution.id]
        else:
            # Otherwise, add it with its semantic similarity score
            combined_results[solution.id] = {'solution': solution, 'score': similarities[solution.id]}

    # Sort by combined score
    sorted_solutions_with_scores = sorted(
        combined_results.values(), key=lambda x: x['score'], reverse=True
    )
    final_sorted_solutions = [item['solution'] for item in sorted_solutions_with_scores]

    if not final_sorted_solutions:
        flash('No solutions found matching your search.', 'info')

    return render_template('search_results.html', title='Search Results', results=final_sorted_solutions, query=query)


@bp.route('/user_profile')
@login_required
def user_profile():
    """Displays the current user's profile, points, and badges."""
    user_badges = current_user.badges.all()
    return render_template('user_profile.html', title='My Profile', user_badges=user_badges)


@bp.route('/collections/reorder', methods=['POST'])
@login_required
def reorder_collections():
    """Handles reordering of collections via AJAX."""
    data = request.get_json()
    if not data or 'collection_ids' not in data:
        return jsonify({'error': 'Missing collection_ids in request.'}), 400

    collection_ids = data['collection_ids']
    
    try:
        for index, collection_id in enumerate(collection_ids):
            collection = db.session.get(Collection, collection_id)
            if collection and collection.owner == current_user:
                collection.order = index
            else:
                # If a collection is not found or doesn't belong to the user,
                # it's an integrity issue or unauthorized access.
                # For now, we'll just skip it, but could log or return an error.
                current_app.logger.warning(f"Unauthorized or missing collection_id {collection_id} during reorder for user {current_user.id}")
        db.session.commit()
        return jsonify({'success': True, 'message': 'Collections reordered successfully.'})
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error reordering collections for user {current_user.id}: {e}")
        return jsonify({'success': False, 'message': 'Failed to reorder collections.'}), 500


@bp.route('/snippet/<int:snippet_id>/move', methods=['GET', 'POST'])
@login_required
def move_snippet(snippet_id):
    """Handles moving or copying a snippet to a different collection."""
    snippet = db.session.get(Snippet, snippet_id)
    if snippet is None or snippet.author != current_user:
        flash('Snippet not found or you do not have permission to modify it.', 'danger')
        return redirect(url_for('main.index'))

    form = MoveSnippetForm()
    form.target_collection.choices = [(c.id, c.name) for c in current_user.collections.all()]
    form.target_collection.choices.insert(0, (0, '--- No Collection ---'))

    if form.validate_on_submit():
        target_collection_id = form.target_collection.data if form.target_collection.data != 0 else None
        action = form.action.data

        if action == 'move':
            snippet.collection_id = target_collection_id
            db.session.commit()
            flash(f'Snippet "{snippet.title}" moved successfully!', 'success')
        elif action == 'copy':
            new_snippet = Snippet(
                title=f"Copy of {snippet.title}",
                description=snippet.description,
                code=snippet.code,
                author=current_user,
                tags=snippet.tags,
                language=snippet.language,
                collection_id=target_collection_id
            )
            new_snippet.generate_and_set_embedding()
            db.session.add(new_snippet)
            db.session.commit()
            current_app.award_points(current_user, 5, "Snippet Copied") # Award points for copying a snippet
            flash(f'Snippet "{snippet.title}" copied successfully!', 'success')
        
        return redirect(url_for('main.view_snippet', snippet_id=snippet.id))

    return render_template('move_snippet.html', title='Move/Copy Snippet', form=form, snippet=snippet)
